# Otterbrix Documentation

Добро пожаловать в документацию проекта Otterbrix!

## Что такое Otterbrix?

**Otterbrix** - это высокопроизводительная open-source база данных для обработки полуструктурированных данных (semi-structured data). Otterbrix объединяет надежность OLTP-подхода с гибкостью OLAP, благодаря инновационной многомерной модели данных.

### Ключевые особенности

- **Schema-Free обработка**: Загружайте и запрашивайте данные без предварительного определения схемы
- **Унифицированная модель данных**: Обрабатывайте плоские (табличные) и иерархические (вложенные) данные в одном движке
- **Высокая производительность**: Колоночно-ориентированный формат для операций реального времени
- **SQL-интерфейс**: Знакомый SQL синтаксис и операции в стиле DataFrame
- **Мультимодальное хранилище**: строки, колонки, документы и высокоразмерные векторы
- **Совместимость с PostgreSQL**: PostgreSQL-совместимый SQL диалект
- **Встраиваемая архитектура**: Написан на C++, легко интегрируется в приложения

### Производительность

- **3-5x быстрее** аналитики на полуструктурированных данных по сравнению с документными БД
- Сопоставимая производительность с колоночными БД (например, DuckDB) на структурированных данных
- **До 10x лучше** эффективность памяти при работе с глубоко вложенными, разреженными структурами
- Практически нулевая задержка для фильтрации и агрегации потоковых данных в реальном времени

## Основная идея

Otterbrix решает ключевую проблему современной аналитики: **как эффективно обрабатывать полуструктурированные данные (JSON, Parquet, ORC, Avro) с производительностью, близкой к традиционным колоночным базам данных?**

Традиционные решения требуют выбора между:
- **Документными БД**: гибкость схемы, но медленная аналитика
- **Колоночными БД**: быстрая аналитика, но требуется строгая схема

**Otterbrix предлагает лучшее из обоих миров** через гибридную архитектуру памяти:
- Arrow формат для эффективных аналитических операций
- Tuple/Flexible-Tuple формат для доступа к полным вложенным объектам
- Автоматический выбор оптимального представления

## Use Cases (Сценарии использования)

### 1. Предобработка и фильтрация данных
Используйте Otterbrix в backend-сервисах для фильтрации или агрегации потоковых данных перед отправкой в тяжелые хранилища данных.

### 2. Аналитика реального времени в микросервисах
Встройте Otterbrix в микросервисы для локальных аналитических возможностей. Обрабатывайте логи или данные датчиков без обращений к централизованным хранилищам.

### 3. Гибридная обработка данных
Обрабатывайте смешанные структурированные и полуструктурированные рабочие нагрузки. Объединяйте реляционные данные с JSON документами.

### 4. Встроенная аналитика в приложениях
Добавляйте продвинутые возможности запросов и отчетности в ваши приложения без внешних зависимостей от БД.

### 5. Ускоренная обработка данных
Используйте оптимизации производительности Otterbrix для тяжелой обработки JSON или трансформации данных.

## Архитектура высокого уровня

```
┌────────────────────────────────────────┐
│         Application Layer              │
│      (Python/C++ API, SQL Client)      │
└────────────────┬───────────────────────┘
                 │
┌────────────────┴────────────────────────┐
│         Otterbrix Engine                │
├─────────────────────────────────────────┤
│ ┌─────────────┐      ┌────────────────┐ │
│ │  SQL Query  │      │  DataFrame     │ │
│ │  Interface  │      │  Interface     │ │
│ └──────┬──────┘      └────────┬───────┘ │
│        └──────────┬────────────┘         │
├───────────────────┼──────────────────────┤
│        ┌──────────▼─────────┐            │
│        │   Query Planner    │            │
│        │  (Logical Plan)    │            │
│        └──────────┬─────────┘            │
│        ┌──────────▼─────────┐            │
│        │  Physical Plan     │            │
│        │   Generator        │            │
│        └──────────┬─────────┘            │
├───────────────────┼──────────────────────┤
│        ┌──────────▼─────────┐            │
│        │  Execution Engine  │            │
│        │  (Vectorized)      │            │
│        └──────────┬─────────┘            │
├───────────────────┼──────────────────────┤
│ ┌────────────────▼──────────────────┐   │
│ │   Multi-Modal Storage Layer       │   │
│ ├───────────┬──────────┬───────────┤   │
│ │   Rows    │ Columns  │    ML     │   │
│ │ (MVCC)    │(Compress)│  Storage  │   │
│ └───────────┴──────────┴───────────┘   │
└────────────────┬────────────────────────┘
                 │
┌────────────────┴────────────────────────┐
│         Storage Manager                 │
│   (Block Manager, Buffer Manager)       │
└────────────────┬────────────────────────┘
                 │
┌────────────────▼────────────────────────┐
│           Data Sources                  │
│  (JSON, Parquet, CSV, Custom Formats)   │
└─────────────────────────────────────────┘
```

## Основные компоненты

Otterbrix состоит из нескольких ключевых компонентов:

### 1. SQL Layer
- **Parser**: PostgreSQL-совместимый SQL парсер
- **Transformer**: Преобразование AST в логический план

### 2. Query Processing
- **Logical Plan**: Абстрактное представление запроса
- **Physical Plan Generator**: Оптимизация и генерация исполняемого плана
- **Physical Plan**: Исполняемые операторы

### 3. Execution Engine
- **Vector Engine**: Векторизованная обработка данных (batches)
- **Operators**: Scan, Filter, Join, Aggregate, Sort и др.

### 4. Storage Layer
- **Table**: Колоночное хранилище с MVCC
- **Row Groups**: Фиксированные блоки для баланса производительности
- **Column Segments**: Сегменты с компрессией и статистиками
- **Index**: B+-tree индексы для быстрого поиска

### 5. Core Infrastructure
- **Catalog**: Метаданные схем, таблиц, индексов
- **Session**: Управление сессиями и транзакциями
- **Memory Management**: PMR allocators, buffer pools
- **Concurrency**: MVCC, row version manager

## Технологический стек

- **Язык**: C++17
- **Зависимости**:
  - Boost 1.86.0
  - actor-zeta (actor framework)
  - abseil-cpp
  - fmt, spdlog (logging)
  - pybind11 (Python bindings)
  - msgpack (serialization)
  - Catch2 (testing)
  - Google Benchmark

## Структура репозитория

```
otterbrix/
├── components/          # Основные компоненты системы
│   ├── sql/            # SQL парсер и трансформер
│   ├── logical_plan/   # Логические планы запросов
│   ├── physical_plan/  # Физические планы запросов
│   ├── physical_plan_generator/  # Генерация физ. планов
│   ├── table/          # Колоночное хранилище
│   ├── vector/         # Векторизованная обработка
│   ├── index/          # Индексные структуры
│   ├── catalog/        # Менеджер метаданных
│   ├── session/        # Управление сессиями
│   ├── expressions/    # Выражения и функции
│   ├── types/          # Система типов
│   └── ...
├── core/               # Базовые утилиты
│   ├── b_plus_tree/   # B+ tree реализация
│   ├── string_heap/   # String memory management
│   ├── file/          # File I/O
│   └── ...
├── services/           # Сервисные компоненты
├── integration/        # Интеграционные тесты
└── docs/              # Документация (этот каталог)
```

## Документация

- **[README.md](README.md)** (этот файл) - Общий обзор проекта
- **[ARCHITECTURE.md](ARCHITECTURE.md)** - Детальная архитектура системы
- **[GETTING_STARTED.md](GETTING_STARTED.md)** - Руководство по началу работы
- **[COMPONENTS.md](COMPONENTS.md)** - Подробное описание компонентов

## Быстрый старт

### Установка через PyPI

```bash
pip install "otterbrix==1.0.1a9"
```

### Базовое использование

```python
from otterbrix import Client

# Создание клиента
client = Client()

# Выполнение SQL запроса
result = client.execute("SELECT * FROM schema.table WHERE count = 1000;")

# Обработка результатов
for row in result:
    print(row)

# Закрытие соединения
client.close()
```

## Сравнение с альтернативами

| Характеристика | DuckDB | Velox | Otterbrix |
|---------------|--------|-------|-----------|
| Использование памяти | Может исчерпать память на больших датасетах | Высокое потребление с обширным кешированием | Эффективный layout для 3 режимов: in-memory, disk-only, hybrid |
| Полуструктурированные данные | Ограниченная поддержка вложенных данных | Поддержка сложных типов, требует определения схемы | Нативная обработка глубоко вложенных структур |
| Модель интеграции | Встраиваемая библиотека с SQL | Библиотека компонентов | Полное встраиваемое решение с SQL и DataFrame API |
| Производительность JSON | Underperforms на сложных JSON структурах | Зависит от host-системы | Оптимизирован для высокопроизводительной JSON аналитики |
| Point Lookups | 10x медленнее SQLite в некоторых паттернах | Оптимизирован для аналитики, не для lookups | Гибридный подход балансирует сканирование и индексный поиск |
| Параллелизм | Ограниченная поддержка concurrent подключений | Зависит от host-системы | Оптимизирован для in-process параллелизма |
| Memory Layout | Традиционный колоночный | Arrow-compatible колоночный | Гибридный tuple и Arrow формат |

## Лицензия и вклад

- Проект open-source
- См. [CONTRIBUTING.md](https://github.com/agdev/otterbrix/blob/main/CONTRIBUTING.md) для требований к вкладу
- См. [Security Policy](https://github.com/agdev/otterbrix/blob/main/.github/SECURITY.md) для информации о безопасности

## Контакты и поддержка

- **GitHub**: https://github.com/agdev/otterbrix
- **Issues**: https://github.com/agdev/otterbrix/issues
- **Email**: team@otterbrix.com

## Дальнейшие шаги

1. Прочитайте [ARCHITECTURE.md](ARCHITECTURE.md) для понимания внутренней архитектуры
2. Изучите [GETTING_STARTED.md](GETTING_STARTED.md) для настройки окружения разработки
3. Ознакомьтесь с [COMPONENTS.md](COMPONENTS.md) для детального описания компонентов
4. Изучите примеры в директории `examples/`

---

**Otterbrix** - мощный, гибкий и производительный движок для обработки полуструктурированных данных, идеально подходящий для встраивания в приложения, микросервисы и data pipelines.
