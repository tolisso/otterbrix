# JSONBench: Сравнение document vs document_table

## Результаты на 1000 записях

### document_table (колоночное хранилище + primary_key_scan)

**Вставка:**
- ✅ 1000 records in 4642ms (215 rec/s)
- Slower insert из-за колоночного формата и эволюции схемы

**SELECT *:**
- ✅ 1000 records in 103ms
- Колоночное сканирование для аналитики

**SELECT с WHERE:**
- ✅ 990 records found

### document (B-tree хранилище)

**Вставка:**
- ⚡ 1000 records in 99ms (10,101 rec/s)
- **46x быстрее вставка** - row-oriented формат

**SELECT *:**
- ⚡ 1000 records in 1ms
- **103x быстрее scan** - прямой доступ к документам

**SELECT с WHERE:**
- ✅ 990 records found

## Сравнительная таблица

| Операция | document (B-tree) | document_table | Преимущество |
|----------|-------------------|----------------|--------------|
| **INSERT** | 99ms (10,101 rec/s) | 4,642ms (215 rec/s) | document 46x быстрее |
| **SELECT *** | 1ms | 103ms | document 103x быстрее |
| **SELECT WHERE** | ✅ 990 records | ✅ 990 records | Одинаково |

## Выводы по производительности

### document (B-tree) - Лучше для:
1. ✅ **Быстрая вставка** - row-oriented, прямая запись
2. ✅ **Точечные запросы по _id** - O(log N) lookup
3. ✅ **Простые CRUD операции**
4. ✅ **Небольшие объемы данных** (< 10K документов)

### document_table - Лучше для:
1. ✅ **Аналитические запросы** - колоночный формат
2. ✅ **Агрегации** (SUM, AVG, COUNT) - векторизация
3. ✅ **Проекции** (SELECT specific columns) - читаем только нужные колонки
4. ✅ **Больше объемы** - лучшее сжатие
5. ✅ **Гибкая схема** - динамическое добавление полей

### Ключевые отличия

**document (B-tree):**
- Row-oriented: `[doc1_all_fields][doc2_all_fields][doc3_all_fields]`
- Быстрый доступ к целым документам
- Каждый документ читается/пишется целиком

**document_table (колоночный):**
- Column-oriented: `[col1: val1,val2,val3...][col2: val1,val2,val3...]`
- Быстрый доступ к отдельным колонкам
- Лучшее сжатие похожих значений

## Проблемы обнаруженные при тестировании

### 1. Генерация _id
❌ **Проблема:** При вставке документов без явного `_id`, генерируются нулевые ID `000000000000000000000000`
- Вызывает коллизии в хэш-таблице `id_to_row_`
- Приводит к падению программы (Aborted core dump)

**Решение:** Нужно исправить генерацию уникальных ObjectId при вставке

### 2. Тест на больших данных
❌ **Проблема:** Тест на 10,000 записях падает с Aborted
- Связано с проблемой #1
- Возможно переполнение памяти при эволюции схемы

## Итоговые рекомендации

### Используйте document (B-tree) если:
- ✅ Много операций INSERT/UPDATE/DELETE
- ✅ Работаете с целыми документами
- ✅ Нужна максимальная скорость записи
- ✅ Небольшие объемы данных

### Используйте document_table если:
- ✅ Много аналитических запросов (агрегации, group by)
- ✅ Часто читаете только часть полей
- ✅ Большие объемы данных (> 100K документов)
- ✅ Нужна гибкость схемы БЕЗ пересоздания таблиц
- ✅ Важно сжатие данных

### С нашим primary_key_scan:
✅ **document_table теперь имеет O(1) lookup по _id** (было O(N))
- На 10K документах: **33.6x ускорение** (1ms vs 37ms)
- Делает document_table более конкурентным для mixed workloads

## Будущие улучшения

1. **Исправить генерацию _id** - уникальные ObjectId для каждого документа
2. **Оптимизировать INSERT** - batch вставка без пересоздания схемы каждый раз
3. **index_scan** - добавить поддержку B-tree индексов на других полях
4. **Hybrid storage** - кэширование горячих документов в row format

---

**Дата:** 08.12.2025  
**Статус:** Тестирование завершено, primary_key_scan работает  
**Проблемы:** Нужно исправить генерацию уникальных _id

